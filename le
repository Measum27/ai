

import random
def drawBoard(board):
    #This function prints out the board that is passed to it.
    #"board" is a list of 10 strings representing the board (ignore index 0)
    print()
    print('   |   |')
    print(' '+board[7]+' | ' + board[8]+' | '+board[9])
    print('   |   |')
    print('-----------')
    print(' '+board[4]+' | ' + board[5]+' | '+board[6])
    print('   |   |')
    print('-----------')
    print('   |   |')
    print(' '+board[1]+' | ' + board[2]+' | '+board[3])
    print('   |   |')


def inputPlayerLetter():
    #Lets the player type which letter they want to be their mark
    #Returns a list with the player's letter as the first item, and the computer's letter as the second.
    #For simplification, keeping X as the player's letter and O as the computer's letter
    return['X','O']
def whoGoesFirst():
    #for simplification letting the computer go first
    return 'computer'
def playAgain():
    #This function returns True if the player wants to play again, otherwise it returns False.
    print('Do you want to play again? (yes or no)')
    return input().lower().startswith('y')
def makeMove(board,letter,move):
    #This function simply marks the planned move (Location of the board with the player's letter.
    board[move]=letter
def isWinner(bo, le):
    #Given a board and a player's letter, this function returns True if that player has won.
    #We use bo instead of board and le instead of letter so we don't have to type as much.
    return ((bo[7]==le and bo[8]==le and bo[9]==le) or # across the top
            (bo[4]==le and bo[5]==le and bo[6]==le) or # across the middle
            (bo[1]==le and bo[2]==le and bo[3]==le) or # across the bottom
            (bo[7]==le and bo[4]==le and bo[1]==le) or #down the left side
            (bo[8]==le and bo[5]==le and bo[2]==le) or #down the middle
            (bo[9]==le and bo[6]==le and bo[3]==le) or #down the right side
            (bo[7]==le and bo[5]==le and bo[3]==le) or #diagonal
            (bo[9]==le and bo[5]==le and bo[1]==le)) #diagonal
def getBoardCopy(board):
    #Make a duplicate of the board list and return it the duplicate
    dupeBoard=[]
    for i in board:
        dupeBoard.append(i)
    return dupeBoard
def isSpaceFree(board, move):
    # Return true if the passed move is free on the passed board.
    return board[move]==''
def getPlayerMove(board):
    #Let the player type in his move
    move=''
    while move not in '1 2 3 4 5 6 7 8 9'.split() or not isSpaceFree(board, int(move)):
        print('What is your next move? (1-9)')
        move=input()
    return int(move)
def chooseRandomMoveFromList(board, movesList):
    #Returns a valid move from the passed list on the passed board.
    #Returns None if there is no valid move.
    possibleMoves=[]
    for i in movesList:
        if isSpaceFree(board, i):
            possibleMoves.append(i)
    if len(possibleMoves)!=0:
        return random.choice(possibleMoves)
    else:
        return None
def getComputerMove(board, computerLetter):
    #Given a board and the computer's letter, determine where to move and return that move.
    if computerLetter=='X':
        playerLetter='O'
    else:
        playerLetter='X'

    # Here is our algorithm for our tic toc toe AI:
    # First, check if we can win in the next move
    for i in range(1,10):
        copy= getBoardCopy(board)
        if isSpaceFree(copy,i):
            makeMove(copy, computerLetter,i)
            return i
    # Check if the player could win on his next move, and block them.
    for i in range(1,10):
        copy=getBoardCopy(board)
        if isSpaceFree(copy,i):
            makeMove(copy, playerLetter, i)
            if isWinner(copy, playerLetter):
                return i
    # Try to take one of the corners, if they are free
    move = chooseRandomMoveFromList(board, [1,3,7,9])
    if move !=None:
        return move
    #Try to take the center, if it is free.
    if isSpaceFree(board,5):
        return 5
    # Move on one of the sides
    return chooseRandomMoveFromList(board,[2,4,6,8])
def isBoardFull(board):
    # Return True if every space on the board has been taken. Otherwise returns False.
    for i in range(1,10):
        if isSpaceFree(board,i):
            return False
    return True



def generateRandomMove(board):
    #function to generate a random move
    return random.randint(1,9)

def generateRandomLetter():
    #function to generate a random letter
    letter = ['X','O']
    return letter[random.randint(0,1)]
def computerVsComputer():
    # function for computer vs computer simulation
    board = ['']*10
    computer1Letter, computer2Letter = generateRandomLetter(), generateRandomLetter()
    turn = whoGoesFirst()
    print('The '+turn + ' will go first.')
    gameIsPlaying = True
    # draw all the moves
    while gameIsPlaying:
        if turn == 'computer1':
            move = generateRandomMove(board)
            makeMove(board,computer1Letter,move)
            print('Computer 1 chooses', move)
            drawBoard(board)
            if isWinner(board,computer1Letter):
                print('Computer 1 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer2'
        else:
            move = generateRandomMove(board)
            makeMove(board,computer2Letter,move)
            print('Computer 2 chooses', move)
            drawBoard(board)
            if isWinner(board,computer2Letter):
                print('Computer 2 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer1'
computerVsComputer()


'''Lookup Table'''

import random
def drawBoard(board):
    # This function prints out the board that is passed to it.
    # "board" is a list of 10 strings representing the board (ignore index 0)
    print()
    print('   |   |')
    print(' '+board[7]+' | ' + board[8]+' | '+board[9])
    print('   |   |')
    print('-----------')
    print(' '+board[4]+' | ' + board[5]+' | '+board[6])
    print('   |   |')
    print('-----------')
    print('   |   |')
    print(' '+board[1]+' | ' + board[2]+' | '+board[3])
    print('   |   |')


def inputPlayerLetter():
    # Lets the player type which letter they want to be their mark
    # Returns a list with the player's letter as the first item, and the computer's letter as the second.
    # For simplification, keeping X as the player's letter and O as the computer's letter
    return ['X', 'O']


def whoGoesFirst():
    # for simplification letting the computer go first
    return 'computer'


def playAgain():
    # This function returns True if the player wants to play again, otherwise it returns False.
    print('Do you want to play again? (yes or no)')
    return input().lower().startswith('y')


def makeMove(board, letter, move):
    # This function simply marks the planned move (Location of the board with the player's letter.
    board[move] = letter


def isWinner(bo, le):
    # Given a board and a player's letter, this function returns True if that player has won.
    # We use bo instead of board and le instead of letter so we don't have to type as much.
    return ((bo[7] == le and bo[8] == le and bo[9] == le) or  # across the top
            (bo[4] == le and bo[5] == le and bo[6] == le) or  # across the middle
            (bo[1] == le and bo[2] == le and bo[3] == le) or  # across the bottom
            (bo[7] == le and bo[4] == le and bo[1] == le) or  # down the left side
            (bo[8] == le and bo[5] == le and bo[2] == le) or  # down the middle
            # down the right side
            (bo[9] == le and bo[6] == le and bo[3] == le) or
            (bo[7] == le and bo[5] == le and bo[3] == le) or  # diagonal
            (bo[9] == le and bo[5] == le and bo[1] == le))  # diagonal

def getBoardCopy(board):
    # Make a duplicate of the board list and return it the duplicate
    dupeBoard = []
    for i in board:
        dupeBoard.append(i)
    return dupeBoard

def isSpaceFree(board, move):
    # Return true if the passed move is free on the passed board.
    return board[move] == ''

def getPlayerMove(board):
    # Let the player type in his move
    move = ''
    while move not in '1 2 3 4 5 6 7 8 9'.split() or not isSpaceFree(board, int(move)):
        print('What is your next move? (1-9)')
        move = input()
    return int(move)

def chooseRandomMoveFromList(board, movesList):
    # Returns a valid move from the passed list on the passed board.
    # Returns None if there is no valid move.
    possibleMoves = []
    for i in movesList:
        if isSpaceFree(board, i):
            possibleMoves.append(i)
    if len(possibleMoves) != 0:
        return random.choice(possibleMoves)
    else:
        return None

def getComputerMove(board, computerLetter):
    # Given a board and the computer's letter, determine where to move and return that move.
    if computerLetter == 'X':
        playerLetter = 'O'
    else:
        playerLetter = 'X'

    # Here is our algorithm for our tic toc toe AI:
    # First, check if we can win in the next move
    for i in range(1, 10):
        copy = getBoardCopy(board)
        if isSpaceFree(copy, i):
            makeMove(copy, computerLetter, i)
            return i
    # Check if the player could win on his next move, and block them.
    for i in range(1, 10):
        copy = getBoardCopy(board)
        if isSpaceFree(copy, i):
            makeMove(copy, playerLetter, i)
            if isWinner(copy, playerLetter):
                return i
    # Try to take one of the corners, if they are free
    move = chooseRandomMoveFromList(board, [1, 3, 7, 9])
    if move != None:
        return move
    # Try to take the center, if it is free.
    if isSpaceFree(board, 5):
        return 5
    # Move on one of the sides
    return chooseRandomMoveFromList(board, [2, 4, 6, 8])


def isBoardFull(board):
    # Return True if every space on the board has been taken. Otherwise returns False.
    for i in range(1, 10):
        if isSpaceFree(board, i):
            return False
    return True

def computerVsComputer():
    # function for computer vs computer simulation using a lookup table approach
    board = ['']*10
    computer1Letter, computer2Letter = 'X', 'O'
    turn = whoGoesFirst()
    print('The '+turn + ' will go first.')
    gameIsPlaying = True

    # initialize the lookup table
    qTable = {}

    # draw all the moves
    while gameIsPlaying:
        if turn == 'computer1':
            # get the current state
            state = getState(board, computer1Letter, computer2Letter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computer1Letter, move)

            # print the move made by computer1
            print('Computer 1 has made a move. Board is:')
            drawBoard(board)

            # get the new state and reward
            newState = getState(board, computer1Letter, computer2Letter)
            reward = getReward(board, computer1Letter, computer2Letter)

            # update the lookup table
            qTable = updateTable(qTable, state, newState, move, reward)

            # check for a win
            if isWinner(board, computer1Letter):
                drawBoard(board)
                print('Computer 1 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer2'
        else:
            # get the current state
            state = getState(board, computer2Letter, computer1Letter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computer2Letter, move)

            # print the move made by computer2
            print('Computer 2 has made a move. Board is:')
            drawBoard(board)

            # get the new state and reward
            newState = getState(board, computer2Letter, computer1Letter)
            reward = getReward(board, computer2Letter, computer1Letter)

            # update the lookup table
            qTable = updateTable(qTable, state, newState, move, reward)

            # check for a win
            if isWinner(board, computer2Letter):
                drawBoard(board)
                print('Computer 2 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer1'



def updateTable(qTable, state, newState, move, reward):
    # update the lookup table
    if state not in qTable:
        qTable[state] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    if newState not in qTable:
        qTable[newState] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    qTable[state][move-1] = qTable[state][move-1] + 0.1 * (reward + 0.9 * max(qTable[newState]) - qTable[state][move-1])
    return qTable

def getState(board, computerLetter, playerLetter):
    # get the current state
    state = ''
    for i in range(1, 10):
        if board[i] == computerLetter:
            state += '1'
        elif board[i] == playerLetter:
            state += '2'
        else:
            state += '0'
    return state

def getReward(board, computerLetter, playerLetter):
    # get the reward
    if isWinner(board, computerLetter):
        reward = 1
    elif isWinner(board, playerLetter):
        reward = -1
    else:
        reward = 0
    return reward

def chooseMove(qTable, state):
    # choose a move using the lookup table
    if state not in qTable:
        qTable[state] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    if random.random() < 0.1:
        move = random.randint(1, 9)
    else:
        move = qTable[state].index(max(qTable[state])) + 1
    return move

computerVsComputer()

def computerVsHuman():
    # function for computer vs human simulation using a lookup table approach
    board = ['']*10
    computerLetter, playerLetter = 'X', 'O'
    turn = whoGoesFirst()
    print('The ' + turn + ' will go first.')

    # initialize the lookup table
    qTable = {}

    # draw all the moves
    while True:
        if turn == 'computer':
            # get the current state
            state = getState(board, computerLetter, playerLetter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computerLetter, move)

            # print the move made by computer
            print('Computer has made a move. Board is:')
            drawBoard(board)

            # check for a win
            if isWinner(board, computerLetter):
                drawBoard(board)
                print('Computer has won the game!')
                break
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'player'
        else:
            # get the player's move
            move = getPlayerMove(board)

            # make the move
            makeMove(board, playerLetter, move)

            # print the move made by the player
            print('Player has made a move. Board is:')
            drawBoard(board)

            # check for a win
            if isWinner(board, playerLetter):
                drawBoard(board)
                print('Player has won the game!')
                break
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer'
computerVsHuman()


'''Computer vs Human'''
import random
def drawBoard(board):
    # This function prints out the board that is passed to it.
    # "board" is a list of 10 strings representing the board (ignore index 0)
    print()
    print('   |   |')
    print(' '+board[7]+' | ' + board[8]+' | '+board[9])
    print('   |   |')
    print('-----------')
    print(' '+board[4]+' | ' + board[5]+' | '+board[6])
    print('   |   |')
    print('-----------')
    print('   |   |')
    print(' '+board[1]+' | ' + board[2]+' | '+board[3])
    print('   |   |')


def inputPlayerLetter():
    # Lets the player type which letter they want to be their mark
    # Returns a list with the player's letter as the first item, and the computer's letter as the second.
    # For simplification, keeping X as the player's letter and O as the computer's letter
    return ['X', 'O']


def whoGoesFirst():
    # for simplification letting the computer go first
    return 'computer'


def playAgain():
    # This function returns True if the player wants to play again, otherwise it returns False.
    print('Do you want to play again? (yes or no)')
    return input().lower().startswith('y')


def makeMove(board, letter, move):
    # This function simply marks the planned move (Location of the board with the player's letter.
    board[move] = letter


def isWinner(bo, le):
    # Given a board and a player's letter, this function returns True if that player has won.
    # We use bo instead of board and le instead of letter so we don't have to type as much.
    return ((bo[7] == le and bo[8] == le and bo[9] == le) or  # across the top
            (bo[4] == le and bo[5] == le and bo[6] == le) or  # across the middle
            (bo[1] == le and bo[2] == le and bo[3] == le) or  # across the bottom
            (bo[7] == le and bo[4] == le and bo[1] == le) or  # down the left side
            (bo[8] == le and bo[5] == le and bo[2] == le) or  # down the middle
            # down the right side
            (bo[9] == le and bo[6] == le and bo[3] == le) or
            (bo[7] == le and bo[5] == le and bo[3] == le) or  # diagonal
            (bo[9] == le and bo[5] == le and bo[1] == le))  # diagonal

def getBoardCopy(board):
    # Make a duplicate of the board list and return it the duplicate
    dupeBoard = []
    for i in board:
        dupeBoard.append(i)
    return dupeBoard

def isSpaceFree(board, move):
    # Return true if the passed move is free on the passed board.
    return board[move] == ''

def getPlayerMove(board):
    # Let the player type in his move
    move = ''
    while move not in '1 2 3 4 5 6 7 8 9'.split() or not isSpaceFree(board, int(move)):
        print('What is your next move? (1-9)')
        move = input()
    return int(move)

def chooseRandomMoveFromList(board, movesList):
    # Returns a valid move from the passed list on the passed board.
    # Returns None if there is no valid move.
    possibleMoves = []
    for i in movesList:
        if isSpaceFree(board, i):
            possibleMoves.append(i)
    if len(possibleMoves) != 0:
        return random.choice(possibleMoves)
    else:
        return None

def getComputerMove(board, computerLetter):
    # Given a board and the computer's letter, determine where to move and return that move.
    if computerLetter == 'X':
        playerLetter = 'O'
    else:
        playerLetter = 'X'

    # Here is our algorithm for our tic toc toe AI:
    # First, check if we can win in the next move
    for i in range(1, 10):
        copy = getBoardCopy(board)
        if isSpaceFree(copy, i):
            makeMove(copy, computerLetter, i)
            return i
    # Check if the player could win on his next move, and block them.
    for i in range(1, 10):
        copy = getBoardCopy(board)
        if isSpaceFree(copy, i):
            makeMove(copy, playerLetter, i)
            if isWinner(copy, playerLetter):
                return i
    # Try to take one of the corners, if they are free
    move = chooseRandomMoveFromList(board, [1, 3, 7, 9])
    if move != None:
        return move
    # Try to take the center, if it is free.
    if isSpaceFree(board, 5):
        return 5
    # Move on one of the sides
    return chooseRandomMoveFromList(board, [2, 4, 6, 8])


def isBoardFull(board):
    # Return True if every space on the board has been taken. Otherwise returns False.
    for i in range(1, 10):
        if isSpaceFree(board, i):
            return False
    return True

def computerVsComputer():
    # function for computer vs computer simulation using a lookup table approach
    board = ['']*10
    computer1Letter, computer2Letter = 'X', 'O'
    turn = whoGoesFirst()
    print('The '+turn + ' will go first.')
    gameIsPlaying = True

    # initialize the lookup table
    qTable = {}

    # draw all the moves
    while gameIsPlaying:
        if turn == 'computer1':
            # get the current state
            state = getState(board, computer1Letter, computer2Letter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computer1Letter, move)

            # print the move made by computer1
            print('Computer 1 has made a move. Board is:')
            drawBoard(board)

            # get the new state and reward
            newState = getState(board, computer1Letter, computer2Letter)
            reward = getReward(board, computer1Letter, computer2Letter)

            # update the lookup table
            qTable = updateTable(qTable, state, newState, move, reward)

            # check for a win
            if isWinner(board, computer1Letter):
                drawBoard(board)
                print('Computer 1 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer2'
        else:
            # get the current state
            state = getState(board, computer2Letter, computer1Letter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computer2Letter, move)

            # print the move made by computer2
            print('Computer 2 has made a move. Board is:')
            drawBoard(board)

            # get the new state and reward
            newState = getState(board, computer2Letter, computer1Letter)
            reward = getReward(board, computer2Letter, computer1Letter)

            # update the lookup table
            qTable = updateTable(qTable, state, newState, move, reward)

            # check for a win
            if isWinner(board, computer2Letter):
                drawBoard(board)
                print('Computer 2 has won the game!')
                gameIsPlaying = False
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer1'



def updateTable(qTable, state, newState, move, reward):
    # update the lookup table
    if state not in qTable:
        qTable[state] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    if newState not in qTable:
        qTable[newState] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    qTable[state][move-1] = qTable[state][move-1] + 0.1 * (reward + 0.9 * max(qTable[newState]) - qTable[state][move-1])
    return qTable

def getState(board, computerLetter, playerLetter):
    # get the current state
    state = ''
    for i in range(1, 10):
        if board[i] == computerLetter:
            state += '1'
        elif board[i] == playerLetter:
            state += '2'
        else:
            state += '0'
    return state

def getReward(board, computerLetter, playerLetter):
    # get the reward
    if isWinner(board, computerLetter):
        reward = 1
    elif isWinner(board, playerLetter):
        reward = -1
    else:
        reward = 0
    return reward

def chooseMove(qTable, state):
    # choose a move using the lookup table
    if state not in qTable:
        qTable[state] = [0, 0, 0, 0, 0, 0, 0, 0, 0]
    if random.random() < 0.1:
        move = random.randint(1, 9)
    else:
        move = qTable[state].index(max(qTable[state])) + 1
    return move

computerVsComputer()

def computerVsHuman():
    # function for computer vs human simulation using a lookup table approach
    board = ['']*10
    computerLetter, playerLetter = 'X', 'O'
    turn = whoGoesFirst()
    print('The ' + turn + ' will go first.')

    # initialize the lookup table
    qTable = {}

    # draw all the moves
    while True:
        if turn == 'computer':
            # get the current state
            state = getState(board, computerLetter, playerLetter)

            # choose a move using the lookup table
            move = chooseMove(qTable, state)

            # make the move
            makeMove(board, computerLetter, move)

            # print the move made by computer
            print('Computer has made a move. Board is:')
            drawBoard(board)

            # check for a win
            if isWinner(board, computerLetter):
                drawBoard(board)
                print('Computer has won the game!')
                break
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'player'
        else:
            # get the player's move
            move = getPlayerMove(board)

            # make the move
            makeMove(board, playerLetter, move)

            # print the move made by the player
            print('Player has made a move. Board is:')
            drawBoard(board)

            # check for a win
            if isWinner(board, playerLetter):
                drawBoard(board)
                print('Player has won the game!')
                break
            else:
                if isBoardFull(board):
                    drawBoard(board)
                    print('The game is a tie!')
                    break
                else:
                    turn = 'computer'
computerVsHuman()


-----------------------------------------
A STAR
----------------------------------------

import heapq

def a_star_search(graph, start, goal, heuristic):
    open_list = [(0, start)]  # Priority queue with f-score and node
    closed_list = set()
    g_scores = {node: float('inf') for node in graph}
    g_scores[start] = 0
    parents = {}

    while open_list:
        _, current_node = heapq.heappop(open_list)

        if current_node == goal:
            return reconstruct_path(parents, start, goal)

        closed_list.add(current_node)

        if current_node in graph:
            for neighbor, edge_cost in graph[current_node].items():
                if neighbor in closed_list:
                    continue

                new_g_score = g_scores[current_node] + edge_cost

                if new_g_score < g_scores[neighbor] or neighbor not in [node for _, node in open_list]:
                    g_scores[neighbor] = new_g_score
                    parents[neighbor] = current_node
                    f_score = new_g_score + heuristic[neighbor]
                    heapq.heappush(open_list, (f_score, neighbor))

    return None

def reconstruct_path(parents, start, goal):
    path = [goal]
    current_node = goal

    while current_node != start:
        current_node = parents[current_node]
        path.append(current_node)

    path.reverse()
    return path

# Example usage:
graph = {
    'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140},
    'Zerind': {'Arad': 75, 'Oradea': 71},
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Timisoara': {'Arad': 118, 'Lugoj': 111},
    'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Craiova': {'Drobeta': 120, 'Rimnicu': 146, 'Pitesti': 138},
    'Rimnicu': {'Craiova': 146, 'Sibiu': 80, 'Pitesti': 97},
    'Sibiu': {'Arad': 140, 'Oradea': 151, 'Rimnicu': 80, 'Fagaras': 99},
    'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
    'Pitesti': {'Rimnicu': 97, 'Craiova': 138, 'Bucharest': 101},
    'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85},
    'Giurgiu': {'Bucharest': 77},
    'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
    'Hirsova': {'Urziceni': 98, 'Eforie': 86},
    'Eforie': {'Hirsova': 86},
    'Vaslui': {'Urziceni': 142, 'Iasi': 92},
    'Iasi': {'Vaslui': 92, 'Neamt': 87},
    'Neamt': {'Iasi': 87}
}

heuristic = {
    'Arad': 366,
    'Bucharest': 0,
    'Craiova': 160,
    'Drobeta': 242,
    'Eforie': 161,
    'Fagaras': 178,
    'Giurgiu': 90,
    'Hirsova': 151,
    'Iasi': 226,
    'Lugoj': 244,
    'Mehadia': 241,
    'Neamt': 234,
    'Oradea': 380,
    'Pitesti': 98,
    'Rimnicu': 193,
    'Sibiu': 253,
    'Timisoara': 329,
    'Urziceni': 80,
    'Vaslui': 199,
    'Zerind': 374
}

start_node = 'Arad'
goal_node = 'Bucharest'

shortest_path = a_star_search(graph, start_node, goal_node, heuristic)
if shortest_path:
    print("Shortest path:", shortest_path)
else:
    print("No path found from", start_node, "to", goal_node)








*******************************************************************************
DFS BFS GREEDY
*******************************************************************************
import heapq


def dfs(graph, start, goal):
    visited = set()
    stack = [start]
    print("Start", start)
    while stack:
        node = stack.pop()
        print("Visiting", node)
        if node == goal:
            print("Reached Goal")
            return True
        if node not in visited:
            visited.add(node)
            stack.extend(graph[node])
    return False


def bfs(graph, start, goal):
    visited = set()
    queue = [start]

    while queue:
        node = queue.pop(0)

        if node == goal:
            print("Reached Goal")
            return True

        if node not in visited:
            visited.add(node)
            if node in graph:
                queue.extend(graph[node])

    return False


def greedy_search(graph, start, goal, heuristic):
    visited = set()
    # Priority queue using heuristic value as priority
    queue = [(heuristic[start], start)]
    print("Start", start)
    while queue:
        _, node = heapq.heappop(queue)
        print("Visiting", node)
        if node == goal:
            print("Reached Goal", visited)
            return True

        if node not in visited:
            visited.add(node)

            if node in graph:  # Check if node exists in the graph dictionary
                for neighbor in graph[node]:
                    if neighbor not in visited:
                        heapq.heappush(queue, (heuristic[neighbor], neighbor))

    return False


graph = {
    "A": ["B", "D"],
    "B": ["C", "E"],
    "C": [],
    "D": ["E", "G"],
    "E": ["C", "F"],
    "F": [],
    "G": []
}

heuristic = {
    "A": 5,
    "B": 4,
    "C": 2,
    "D": 3,
    "E": 2,
    "F": 1,
    "G": 0
}

print(greedy_search(graph, "A", "G", heuristic))
# print(dfs(graph, "A", "G"))




*******************************************************************************
EVOLTUION Algo
*******************************************************************************

import random

# Problem-specific evaluation function
def evaluate_solution(solution):
    # Calculate fitness or objective value of the solution
    # Return the fitness value
    return sum(solution)

# Evolutionary Algorithm
def evolutionary_algorithm(population_size, num_generations):
    # Generate an initial population of random solutions
    population = [random.choices([0, 1], k=10) for _ in range(population_size)]

    for generation in range(num_generations):
        # Evaluate fitness of each solution in the population
        fitness_values = [evaluate_solution(solution) for solution in population]

        # Select parents for reproduction (e.g., tournament selection)
        parents = random.choices(population, weights=fitness_values, k=population_size)

        # Create offspring through crossover (e.g., one-point crossover)
        offspring = []
        for i in range(population_size):
            parent1 = random.choice(parents)
            parent2 = random.choice(parents)
            crossover_point = random.randint(0, len(parent1))
            child = parent1[:crossover_point] + parent2[crossover_point:]
            offspring.append(child)

        # Apply mutation to the offspring (e.g., bit-flip mutation)
        for i in range(population_size):
            for j in range(len(offspring[i])):
                if random.random() < mutation_rate:
                    offspring[i][j] = 1 - offspring[i][j]

        # Replace the current population with the offspring
        population = offspring

    # Return the best solution found
    best_solution = max(population, key=lambda x: evaluate_solution(x))
    return best_solution

# Example usage
population_size = 1000
num_generations = 50
mutation_rate = 0.01

best_solution = evolutionary_algorithm(population_size, num_generations)
print("Best solution:", best_solution)
print("Fitness:", evaluate_solution(best_solution))



*******************************************************************************
Genetic Algo
*******************************************************************************
#GENETIC ALGO SIMPLEST
import random

# Genetic Algorithm Parameters
population_size = 50
chromosome_length = 10
generations = 100

# Generate Initial Population
population = []
for _ in range(population_size):
    lst = []
    for _ in range(chromosome_length):
        lst.append(random.randint(0,1))
    population.append(lst)

# Fitness Function (Modify according to your problem)
def fitness_function(chromosome):
    target = [1, 1, 0, 1, 0, 0, 1, 0, 1, 0]  # Example target chromosome
    return sum(c1 == c2 for c1, c2 in zip(chromosome, target))

# Genetic Algorithm
for _ in range(generations):
    population = sorted(population, key=fitness_function, reverse=True)
    parents = population[:population_size // 2]

    new_population = []
    for parent1, parent2 in zip(parents[::2], parents[1::2]):

        crossover_point = 4
        child1 = parent1[:crossover_point] + parent2[crossover_point:]
        child2 = parent2[:crossover_point] + parent1[crossover_point:]
        mutated_child1 = child1[:3] + [1-child1[3]] + child1[4:]
        mutated_child2 = child2[:3] + [1-child2[3]] + child2[4:]
        new_population.extend([mutated_child1, mutated_child2])

    population = new_population

# Find the best chromosome in the final population
best_solution = max(population, key=fitness_function)

print("Best Solution:", best_solution)
print("Fitness:", fitness_function(best_solution))

*******************************************************************************
Particle Swarm Optimization
*******************************************************************************
#Particle Swarm Optimization WITH ERROR
import random

# Particle Swarm Optimization Parameters
num_particles = 50
num_dimensions = 10
max_iterations = 100
c1 = 2.0  # Cognitive parameter
c2 = 2.0  # Social parameter
w = 0.7   # Inertia weight

# Initialize Particle Positions, Velocities, and Best Positions
particles = [[random.uniform(0, 1) for _ in range(num_dimensions)] for _ in range(num_particles)]
velocities = [[random.uniform(-1, 1) for _ in range(num_dimensions)] for _ in range(num_particles)]
best_positions = particles.copy()

# Fitness Function (Modify according to your problem)
def fitness_function(position):
    target = [1, 1, 0, 1, 0, 0, 1, 0, 1, 0]  # Example target position
    return sum(c1 == c2 for c1, c2 in zip(position, target))

# Particle Swarm Optimization
global_best_position = None
global_best_fitness = float('-inf')

for _ in range(max_iterations):
    for i in range(num_particles):
        particle = particles[i]
        velocity = velocities[i]
        best_position = best_positions[i]

        # Update Particle Velocity
        for j in range(num_dimensions):
            r1 = random.uniform(0, 1)
            r2 = random.uniform(0, 1)
            velocity[j] = (w * velocity[j]) + (c1 * r1 * (best_position[j] - particle[j])) + (c2 * r2 * (global_best_position[j] - particle[j]))

        # Update Particle Position
        for j in range(num_dimensions):
            particle[j] = particle[j] + velocity[j]

        # Update Best Positions
        fitness = fitness_function(particle)
        if fitness > fitness_function(best_position):
            best_positions[i] = particle

        # Update Global Best
        if fitness > global_best_fitness:
            global_best_fitness = fitness
            global_best_position = particle

# Print the Best Solution and its Fitness
print("Best Solution:", global_best_position)
print("Fitness:", global_best_fitness)

******************************************************************************
Ant Colony Optimiazation
*****************************************************************************
import random

# Ant Colony Optimization Parameters
num_ants = 50
num_iterations = 100
alpha = 1.0  # Pheromone factor
beta = 2.0   # Heuristic factor
evaporation_rate = 0.5

# Graph representation (Modify according to your problem)
graph = [
    [0, 2, 4, 1],
    [2, 0, 1, 5],
    [4, 1, 0, 3],
    [1, 5, 3, 0]
]

num_cities = len(graph)

# Initialize Pheromone Matrix
pheromone = [[1.0 for _ in range(num_cities)] for _ in range(num_cities)]

# Ant Colony Optimization
best_path = None
best_distance = float('inf')

for _ in range(num_iterations):
    paths = []

    # Construct Solutions
    for _ in range(num_ants):
        start_city = random.randint(0, num_cities - 1)
        path = [start_city]
        visited = [False] * num_cities
        visited[start_city] = True

        for _ in range(num_cities - 1):
            current_city = path[-1]
            next_city = None
            probabilities = []

            # Compute Probabilities for the Next City
            for city in range(num_cities):
                if not visited[city]:
                    pheromone_value = pheromone[current_city][city]
                    heuristic_value = 1.0 / graph[current_city][city]
                    probability = pheromone_value * alpha * heuristic_value * beta
                    probabilities.append((city, probability))

            total_probability = sum(prob for _, prob in probabilities)
            probabilities = [(city, prob / total_probability) for city, prob in probabilities]

            # Choose Next City based on Probability
            random_value = random.uniform(0, 1)
            cumulative_probability = 0.0
            for city, probability in probabilities:
                cumulative_probability += probability
                if random_value <= cumulative_probability:
                    next_city = city
                    break

            path.append(next_city)
            visited[next_city] = True

        paths.append(path)

    # Update Pheromone Matrix
    for i in range(num_cities):
        for j in range(num_cities):
            if i != j:
                pheromone[i][j] *= (1 - evaporation_rate)

    for path in paths:
        distance = sum(graph[path[i]][path[i+1]] for i in range(num_cities - 1))
        if distance < best_distance:
            best_distance = distance
            best_path = path

        for i in range(num_cities - 1):
            pheromone[path[i]][path[i+1]] += 1.0 / distance

# Print the Best Path and its Distance
print("Best Path:", best_path)
print("Distance:", best_distance)
**************TIC TAC TOE wiht minimax*******************

import random

def print_board(board):
    """
    Prints the Tic-Tac-Toe board.
    """
    print("---------")
    for row in board:
        print("|", end="")
        for cell in row:
            print(cell, end="|")
        print("\n---------")

def is_full(board):
    """
    Checks if the board is full.
    """
    for row in board:
        for cell in row:
            if cell == "-":
                return False
    return True

def get_winner(board):
    """
    Determines the winner of the game.
    Returns 'X' if X wins, 'O' if O wins, or '-' if there is no winner yet.
    """
    # Check rows
    for row in board:
        if row[0] == row[1] == row[2] != "-":
            return row[0]

    # Check columns
    for col in range(3):
        if board[0][col] == board[1][col] == board[2][col] != "-":
            return board[0][col]

    # Check diagonals
    if board[0][0] == board[1][1] == board[2][2] != "-":
        return board[0][0]
    if board[0][2] == board[1][1] == board[2][0] != "-":
        return board[0][2]

    return "-"

def get_empty_cells(board):
    """
    Returns a list of empty cells on the board.
    """
    empty_cells = []
    for i in range(3):
        for j in range(3):
            if board[i][j] == "-":
                empty_cells.append((i, j))
    return empty_cells

def evaluate(board):
    """
    Evaluates the current state of the board.
    Returns +1 if X wins, -1 if O wins, or 0 for a tie.
    """
    winner = get_winner(board)
    if winner == "X":
        return 1
    elif winner == "O":
        return -1
    else:
        return 0

def minimax(board, depth, is_maximizing):
    """
    Minimax algorithm implementation.
    """
    if get_winner(board) != "-":
        return evaluate(board)

    if is_full(board):
        return 0

    if is_maximizing:
        best_score = float("-inf")
        for cell in get_empty_cells(board):
            i, j = cell
            board[i][j] = "X"
            score = minimax(board, depth + 1, False)
            board[i][j] = "-"
            best_score = max(score, best_score)
        return best_score

    else:
        best_score = float("inf")
        for cell in get_empty_cells(board):
            i, j = cell
            board[i][j] = "O"
            score = minimax(board, depth + 1, True)
            board[i][j] = "-"
            best_score = min(score, best_score)
        return best_score

def get_best_move(board):
    """
    Finds the best move for the AI using the Minimax algorithm.
    """
    best_score = float("-inf")
    best_move = None
    for cell in get_empty_cells(board):
        i, j = cell
        board[i][j] = "X"
        score = minimax(board, 0, False)
        board[i][j] = "-"
        if score > best_score:
            best_score = score
            best_move = cell
    return best_move

def play_game():
    """
    Plays a simplified Tic-Tac-Toe game against the AI.
    """
    board = [["-" for _ in range(3)] for _ in range(3)]
    print("Welcome to Simplified Tic-Tac-Toe!")
    print_board(board)

    while True:
        # Player's turn
        position = int(input("Enter the position on the board (1-9): "))
        row = (position - 1) // 3
        col = (position - 1) % 3
        if board[row][col] == "-":
            board[row][col] = "O"
        else:
            print("Invalid move! Try again.")
            continue

        # Check for game over
        winner = get_winner(board)
        if winner == "O":
            print("Congratulations! You won!")
            break
        elif is_full(board):
            print("It's a tie!")
            break

        # AI's turn
        print("AI is thinking...")
        ai_move = get_best_move(board)
        board[ai_move[0]][ai_move[1]] = "X"

        # Check for game over
        winner = get_winner(board)
        if winner == "X":
            print("AI wins!")
            break
        elif is_full(board):
            print("It's a tie!")
            break

        print_board(board)

play_game()



***************************************************************
NAIVE BIAS
***************************************************************

import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import confusion_matrix

url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/dermatology/dermatology.data'
column_names = ['erythema', 'scaling', 'definite borders', 'itching', 'koebner phenomenon',
                'polygonal papules', 'follicular papules', 'oral mucosal involvement', 'knee and elbow involvement',
                'scalp involvement', 'family history', 'melanin incontinence', 'eosinophils in the infiltrate',
                'PNL infiltrate', 'fibrosis of the papillary dermis', 'exocytosis', 'acanthosis',
                'hyperkeratosis', 'parakeratosis', 'clubbing of the rete ridges', 'elongation of the rete ridges',
                'thinning of the suprapapillary epidermis', 'spongiform pustule', 'munro microabcess',
                'focal hypergranulosis', 'disappearance of the granular layer', 'vacuolisation and damage of basal layer',
                'spongiosis', 'saw-tooth appearance of retes', 'follicular horn plug', 'perifollicular parakeratosis',
                'inflammatory monoluclear inflitrate', 'band-like infiltrate', 'age', 'class']
df = pd.read_csv(url, names=column_names)
df.replace('?', pd.NA, inplace=True)
df.fillna(df.mode().iloc[0], inplace=True)

X = df.iloc[:, :-1]
y = df.iloc[:, -1]
print(X)
print(y)

split_percentages = [(0.6, 0.4), (0.7, 0.3), (0.8, 0.2)]

for split in split_percentages:
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=split[1], random_state=42)

    nb_classifier = GaussianNB()
    nb_classifier.fit(X_train, y_train)

    k = 5
    cross_val_scores = cross_val_score(nb_classifier, X_train, y_train, cv=k)

    print(f"Train/Test Split: {split[0] * 100}% / {split[1] * 100}%")
    print(f"Mean Accuracy (Cross-validation): {cross_val_scores.mean():.4f}")
    print()

    y_pred = nb_classifier.predict(X_test)

    cm = confusion_matrix(y_test, y_pred)
    print("Confusion Matrix:")
    print(cm)
    print()

    accuracy = (cm.diagonal().sum() / cm.sum()) * 100
    precision = cm[1][1] / (cm[1][1] + cm[0][1])
    recall = cm[1][1] / (cm[1][1] + cm[1][0])

    print(f"Accuracy: {accuracy:.2f}%")
    print(f"Precision: {precision:.2f}")
    print(f"Recall: {recall:.2f}")
    print("--------------------------------------------")



***************************************************
A*STARR
***************************************************


import heapq

def a_star_search(graph, start, goal, heuristic):
    open_list = [(0, start)]  # Priority queue with f-score and node
    closed_list = set()
    g_scores = {node: float('inf') for node in graph}
    g_scores[start] = 0
    parents = {}

    while open_list:
        _, current_node = heapq.heappop(open_list)

        if current_node == goal:
            return reconstruct_path(parents, start, goal)

        closed_list.add(current_node)

        if current_node in graph:
            for neighbor, edge_cost in graph[current_node].items():
                if neighbor in closed_list:
                    continue

                new_g_score = g_scores[current_node] + edge_cost

                if new_g_score < g_scores[neighbor] or neighbor not in [node for _, node in open_list]:
                    g_scores[neighbor] = new_g_score
                    parents[neighbor] = current_node
                    f_score = new_g_score + heuristic[neighbor]
                    heapq.heappush(open_list, (f_score, neighbor))

    return None

def reconstruct_path(parents, start, goal):
    path = [goal]
    current_node = goal

    while current_node != start:
        current_node = parents[current_node]
        path.append(current_node)

    path.reverse()
    return path

# Example usage:
graph = {
    'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140},
    'Zerind': {'Arad': 75, 'Oradea': 71},
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Timisoara': {'Arad': 118, 'Lugoj': 111},
    'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Craiova': {'Drobeta': 120, 'Rimnicu': 146, 'Pitesti': 138},
    'Rimnicu': {'Craiova': 146, 'Sibiu': 80, 'Pitesti': 97},
    'Sibiu': {'Arad': 140, 'Oradea': 151, 'Rimnicu': 80, 'Fagaras': 99},
    'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
    'Pitesti': {'Rimnicu': 97, 'Craiova': 138, 'Bucharest': 101},
    'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85},
    'Giurgiu': {'Bucharest': 77},
    'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
    'Hirsova': {'Urziceni': 98, 'Eforie': 86},
    'Eforie': {'Hirsova': 86},
    'Vaslui': {'Urziceni': 142, 'Iasi': 92},
    'Iasi': {'Vaslui': 92, 'Neamt': 87},
    'Neamt': {'Iasi': 87}
}

heuristic = {
    'Arad': 366,
    'Bucharest': 0,
    'Craiova': 160,
    'Drobeta': 242,
    'Eforie': 161,
    'Fagaras': 178,
    'Giurgiu': 90,
    'Hirsova': 151,
    'Iasi': 226,
    'Lugoj': 244,
    'Mehadia': 241,
    'Neamt': 234,
    'Oradea': 380,
    'Pitesti': 98,
    'Rimnicu': 193,
    'Sibiu': 253,
    'Timisoara': 329,
    'Urziceni': 80,
    'Vaslui': 199,
    'Zerind': 374
}

start_node = 'Arad'
goal_node = 'Bucharest'

shortest_path = a_star_search(graph, start_node, goal_node, heuristic)
if shortest_path:
    print("Shortest path:", shortest_path)
else:
    print("No path found from", start_node, "to", goal_node)


**************************************************
GENETIC ALGORITHM
**************************************************

import numpy as np

def fitness_function(x):
    # Replace this function with your own fitness function
    return x**2

def initialize_population(pop_size, num_variables):
    return np.random.rand(pop_size, num_variables)

def selection(population, fitness_values):
    # Perform tournament selection
    idx = np.random.choice(len(population), size=len(population), replace=True)
    selected = population[idx]
    selected_fitness = fitness_values[idx]
    return selected, selected_fitness

def crossover(parent1, parent2):
    # Perform single-point crossover
    crossover_point = np.random.randint(1, len(parent1))
    child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
    child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
    return child1, child2

def mutation(individual, mutation_rate):
    # Perform bit-flip mutation
    mutated_individual = individual.copy()
    for i in range(len(mutated_individual)):
        if np.random.rand() < mutation_rate:
            mutated_individual[i] = 1 - mutated_individual[i]
    return mutated_individual

def genetic_algorithm(pop_size, num_generations, mutation_rate):
    num_variables = 10  # Change this value according to your problem's dimensions
    population = initialize_population(pop_size, num_variables)

    for generation in range(num_generations):
        fitness_values = np.array([fitness_function(individual) for individual in population])
        best_index = np.argmax(fitness_values)
        best_solution = population[best_index]
        print(f"Generation {generation+1}, Best Fitness: {fitness_function(best_solution)}")

        selected, selected_fitness = selection(population, fitness_values)
        new_population = []

        for i in range(0, pop_size, 2):
            parent1, parent2 = selected[i], selected[i + 1]
            child1, child2 = crossover(parent1, parent2)
            child1 = mutation(child1, mutation_rate)
            child2 = mutation(child2, mutation_rate)
            new_population.append(child1)
            new_population.append(child2)

        population = np.array(new_population)

    return best_solution

if _name_ == "_main_":
    pop_size = 100
    num_generations = 50
    mutation_rate = 0.01

    best_solution = genetic_algorithm(pop_size, num_generations, mutation_rate)
    print("Best Solution:", best_solution)
    print("Best Fitness:", fitness_function(best_solution))



************************************************
HILL CLIMBING
************************************************

import random

def objective_function(x, y):
    """
    Objective function to evaluate the state.
    """
    return (1 - x)*2 + 100(y - x*2)*2

def generate_neighbor(x, y):
    """
    Generates a random neighbor state by making a small change to the current state.
    """
    neighbor_x = x + random.uniform(-0.1, 0.1)
    neighbor_y = y + random.uniform(-0.1, 0.1)
    return neighbor_x, neighbor_y

def hill_climbing(initial_x, initial_y):
    """
    Hill Climbing algorithm implementation.
    """
    current_x = initial_x
    current_y = initial_y
    current_score = objective_function(current_x, current_y)

    while True:
        neighbor_x, neighbor_y = generate_neighbor(current_x, current_y)
        neighbor_score = objective_function(neighbor_x, neighbor_y)

        if neighbor_score < current_score:
            current_x = neighbor_x
            current_y = neighbor_y
            current_score = neighbor_score
        else:
            break

    return current_x, current_y, current_score

# Example usage
initial_x = random.uniform(-2, 2)
initial_y = random.uniform(-2, 2)
final_x, final_y, final_score = hill_climbing(initial_x, initial_y)
print("Final State (x, y):", final_x, final_y)
print("Final Score:", final_score)




************************************************
LINEAR REGRESSION
************************************************


import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error,mean_squared_error

df = pd.read_excel("weather.xlsx")
# print(df.head(5))

y = df["Basel Temperature [2 m elevation corrected]"].values.reshape(-1,1) # column vector conversion
x = df["Basel Growing Degree Days [2 m elevation corrected]"].values.reshape(-1,1)

print(x.shape)
print(y.shape)

plt.scatter(x[::1000],y[::1000])
plt.title('Basel Temp vs Basel Growing Degree Days ')
plt.xlabel("Basel Growing Degree Days")
plt.ylabel("Basel Temp")
plt.show()

x = x[~np.isnan(x).any(axis=1)]
y = y[~np.isnan(y).any(axis=1)]

print(x.shape)
print(y.shape)

xTrain , xTest , yTrain , yTest = train_test_split(x,y,test_size=0.2,random_state = 0)

lReg = LinearRegression()
lReg.fit(xTrain,yTrain)

yPrediction = lReg.predict(X=xTest)

yPrediction = pd.DataFrame ({"Actual": yTest.flatten(), "Predict":yPrediction.flatten()})
print(yPrediction.head(5))


plt.scatter(xTrain[::1000] , yTrain[::1000] , color = "red")
plt.plot(xTrain[::500] , lReg.predict(xTrain)[::500], color = "blue")
plt.title('Basel Temp vs Basel Growing Degree Days ')
plt.xlabel("Basel Growing Degree Days")
plt.ylabel("Basel Temp")
plt.show()


print("Mean Absolute Error:", mean_absolute_error(xTrain ,yTrain))
print("Mean Squared Error:",mean_squared_error(xTrain ,yTrain))
print("Root Mean Squared Error:", np.sqrt(mean_squared_error(xTrain ,yTrain)))

